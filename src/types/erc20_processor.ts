/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Networkish } from "@ethersproject/providers";
import {
  Context,
  getProvider,
  BaseProcessor,
  ContractWrapper,
} from "@sentio/sdk";
import { PromiseOrValue } from "./common";
import { ERC20, ERC20__factory } from "./index";
import {
  ApprovalEvent,
  ApprovalEventFilter,
  TransferEvent,
  TransferEventFilter,
} from "./ERC20";
class ERC20ContractWrapper extends ContractWrapper<ERC20> {
  constructor(contract: ERC20) {
    super(contract);
  }

  allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>) {
    return this.contract.allowance(owner, spender, {
      blockTag: this.block.number,
    });
  }

  balanceOf(account: PromiseOrValue<string>) {
    return this.contract.balanceOf(account, { blockTag: this.block.number });
  }

  decimals() {
    return this.contract.decimals({ blockTag: this.block.number });
  }

  totalSupply() {
    return this.contract.totalSupply({ blockTag: this.block.number });
  }
}

export type ERC20Context = Context<ERC20, ERC20ContractWrapper>;

export class ERC20Processor extends BaseProcessor<ERC20, ERC20ContractWrapper> {
  bindInternal(address: string, network: Networkish = 1) {
    const contract = ERC20__factory.connect(address, getProvider(network));
    return new ERC20ContractWrapper(contract);
  }

  onApproval(
    handler: (event: ApprovalEvent, ctx: ERC20Context) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[]
  ): ERC20Processor {
    if (!filter) {
      filter = this.contract.filters.Approval(null, null, null);
    }
    super.onEvent(handler, filter);
    return this;
  }

  onTransfer(
    handler: (event: TransferEvent, ctx: ERC20Context) => void,
    filter?: TransferEventFilter | TransferEventFilter[]
  ): ERC20Processor {
    if (!filter) {
      filter = this.contract.filters.Transfer(null, null, null);
    }
    super.onEvent(handler, filter);
    return this;
  }

  private static templateContract = ERC20__factory.connect("", getProvider(1));

  static filters = ERC20Processor.templateContract.filters;

  static bind(
    address: string,
    network: Networkish = 1,
    name = "ERC20"
  ): ERC20Processor {
    return new ERC20Processor(address, name, network);
  }
}
